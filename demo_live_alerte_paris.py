#!/usr/bin/env python3
"""
D√©monstration GuardianNav LIVE - Intelligence artificielle en temps r√©el
======================================================================

Sc√©nario LIVE : Utilisateur en alerte pr√®s des locaux Google Paris √† 23h00
- Utilise les vraies APIs Google Cloud (Vertex AI, Maps, TTS)
- Intelligence dynamique pour analyser la situation r√©elle
- Recherche de refuges en temps r√©el via Google Maps
- G√©n√©ration d'emails d'urgence personnalis√©s avec vraie localisation
- Utilise la configuration d'API r√©elle (api_keys.yaml)

REQUIS : 
- Fichier api_keys.yaml configur√© avec vraies cl√©s API Google Cloud
- Vertex AI activ√© et configur√©
- Google Maps API activ√©e
- Text-to-Speech API activ√©e

Usage : python demo_live_alerte_paris.py
"""

import sys
import os
import json
import yaml
import time
import googlemaps
from datetime import datetime
from typing import Dict, List, Tuple, Optional
import logging

# Ajouter le r√©pertoire parent au path pour les imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from guardian.guardian_agent import GuardianOrchestrator
from guardian.speech_agent import SpeechAgent
from guardian.vertex_ai_agent import VertexAIAgent
from guardian.emergency_email_generator import EmergencyEmailGenerator

class DemoLiveAlerteParis:
    """
    D√©monstration LIVE avec vraies APIs pour tester l'intelligence de GuardianNav
    """
    
    def __init__(self):
        """Initialisation de la d√©monstration LIVE"""
        self.setup_logging()
        self.logger = logging.getLogger(__name__)
        
        # Localisation Google Paris (coordonn√©es r√©elles)
        self.location_google_paris = {
            "latitude": 48.8756,
            "longitude": 2.3335,
            "address": "8 Rue de Londres, 75009 Paris",
            "quartier": "9√®me arrondissement",
            "metro_proche": "Europe (Ligne 3)"
        }
        
        # Charger la configuration API r√©elle
        self.api_config = self.load_api_config()
        
        # Initialiser les clients API Google
        self.google_maps_client = None
        self.init_google_apis()
        
        # Initialiser les agents GuardianNav avec vraie config
        self.init_agents()
    
    def setup_logging(self):
        """Configuration du logging pour la d√©mo"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.StreamHandler(sys.stdout)
            ]
        )
    
    def load_api_config(self) -> Dict:
        """Charge la configuration API depuis api_keys.yaml (avec fallback si pas configur√©)"""
        try:
            config_path = os.path.join(os.path.dirname(__file__), 'api_keys.yaml')
            
            if not os.path.exists(config_path):
                self.logger.warning("‚ö†Ô∏è  Fichier api_keys.yaml non trouv√© - Mode d√©monstration")
                return self.get_demo_config()
            
            with open(config_path, 'r', encoding='utf-8') as f:
                config = yaml.safe_load(f)
            
            # V√©rifier quelles APIs sont configur√©es (sans forcer)
            api_status = {}
            api_paths = [
                'google_cloud.services.maps_api_key',
                'google_cloud.services.text_to_speech_api_key',
                'google_cloud.project_id'
            ]
            
            for api_path in api_paths:
                keys = api_path.split('.')
                current = config
                configured = True
                try:
                    for key in keys:
                        if key not in current:
                            configured = False
                            break
                        current = current[key]
                    
                    if isinstance(current, str) and current.startswith('YOUR_'):
                        configured = False
                        
                    api_status[api_path] = configured
                except:
                    api_status[api_path] = False
            
            # Afficher le status des APIs
            configured_apis = [api for api, status in api_status.items() if status]
            missing_apis = [api for api, status in api_status.items() if not status]
            
            if configured_apis:
                self.logger.info(f"‚úÖ APIs configur√©es : {len(configured_apis)}/{len(api_paths)}")
            
            if missing_apis:
                self.logger.warning(f"‚ö†Ô∏è  APIs manquantes : {len(missing_apis)} (mode d√©grad√©)")
            
            return config
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur chargement configuration : {e}")
            self.logger.info("üîÑ Fallback vers configuration de d√©monstration")
            return self.get_demo_config()
    
    def get_demo_config(self) -> Dict:
        """Configuration de d√©monstration quand les APIs ne sont pas configur√©es"""
        return {
            'google_cloud': {
                'project_id': 'demo-project',
                'services': {
                    'maps_api_key': 'DEMO_MODE',
                    'text_to_speech_api_key': 'DEMO_MODE'
                }
            },
            'emergency_contacts': [
                {
                    'name': 'Contact D√©mo 1',
                    'email': 'demo1@example.com',
                    'relation': 'famille',
                    'phone': '+33 6 XX XX XX XX'
                },
                {
                    'name': 'Contact D√©mo 2', 
                    'email': 'demo2@example.com',
                    'relation': 'ami',
                    'phone': '+33 6 XX XX XX XX'
                }
            ]
        }
    
    def init_google_apis(self):
        """Initialise les clients API Google si les cl√©s sont configur√©es"""
        try:
            # Google Maps API
            maps_api_key = self.api_config['google_cloud']['services']['maps_api_key']
            
            if maps_api_key and not maps_api_key.startswith('YOUR_') and maps_api_key != 'DEMO_MODE':
                self.google_maps_client = googlemaps.Client(key=maps_api_key)
                self.logger.info("‚úÖ Google Maps API initialis√©e (LIVE)")
            else:
                self.google_maps_client = None
                self.logger.info("‚ö†Ô∏è  Google Maps en mode simulation (cl√© non configur√©e)")
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur initialisation Google APIs : {e}")
            self.google_maps_client = None

    def init_agents(self):
        """Initialisation des agents GuardianNav avec vraie configuration"""
        # Initialiser les flags par d√©faut
        self.vocal_available = False
        self.ai_available = False 
        self.email_available = False
        self.guardian = None
        self.speech_agent = None
        self.vertex_ai = None
        self.email_generator = None
        
        # Agent principal avec vraie configuration
        try:
            self.guardian = GuardianOrchestrator(self.api_config)
            print("ü§ñ Agent principal GuardianNav activ√© (mode LIVE)")
        except Exception as e:
            print(f"‚ùå Erreur agent principal : {e}")
            self.guardian = None
        
        # Agent vocal avec vraies APIs Google TTS
        try:
            self.speech_agent = SpeechAgent()
            self.vocal_available = True
            print("üîä Agent vocal Google TTS activ√© (mode LIVE)")
        except Exception as e:
            self.speech_agent = None
            self.vocal_available = False
            print(f"‚ùå Agent vocal non disponible : {e}")
        
        # Agent IA Vertex AI (intelligence r√©elle)
        try:
            self.vertex_ai = VertexAIAgent()
            self.ai_available = True
            print("üß† Vertex AI activ√© - Intelligence artificielle LIVE")
        except Exception as e:
            self.vertex_ai = None
            self.ai_available = False
            print(f"‚ùå Vertex AI non disponible : {e}")
            
        # G√©n√©rateur d'email d'urgence avec vraies APIs
        try:
            self.email_generator = EmergencyEmailGenerator()
            self.email_available = True
            print("üìß G√©n√©rateur d'email d'urgence activ√© (mode LIVE)")
        except Exception as e:
            self.email_generator = None
            self.email_available = False
            print(f"‚ùå Email generator non disponible : {e}")
            
        # V√©rifier que les composants critiques sont disponibles
        critical_missing = []
        if not self.ai_available:
            critical_missing.append("Vertex AI")
        if not self.google_maps_client:
            critical_missing.append("Google Maps")
            
        if critical_missing:
            print(f"‚ö†Ô∏è  ATTENTION: APIs critiques manquantes : {', '.join(critical_missing)}")
            print("   La d√©monstration fonctionnera en mode d√©grad√©")
        else:
            print(f"‚úÖ D√©monstration LIVE pr√™te - Toutes les APIs connect√©es")
    
    def find_refuges_dynamically(self, user_message: str) -> List[Dict]:
        """
        Recherche dynamique de refuges via Google Maps API et intelligence Vertex AI
        """
        refuges = []
        
        if not self.google_maps_client:
            return self.get_fallback_refuges()
        
        try:
            print("üîç Recherche intelligente de refuges via Google Maps...")
            
            # Coordonn√©es de base
            location = (self.location_google_paris['latitude'], self.location_google_paris['longitude'])
            
            # Types de lieux s√ªrs √† rechercher (prioris√©s par l'IA)
            search_queries = [
                "police station",
                "hospital",
                "pharmacy",
                "hotel",
                "metro station"
            ]
            
            for query in search_queries:
                try:
                    # Recherche Google Places
                    places_result = self.google_maps_client.places_nearby(
                        location=location,
                        radius=2000,  # 2km de rayon
                        keyword=query,
                        open_now=True  # Seulement les lieux ouverts
                    )
                    
                    for place in places_result.get('results', [])[:2]:  # Limiter √† 2 par cat√©gorie
                        # Calculer la distance et le temps de trajet
                        directions = self.google_maps_client.directions(
                            origin=location,
                            destination=(place['geometry']['location']['lat'], 
                                       place['geometry']['location']['lng']),
                            mode="walking"
                        )
                        
                        if directions and directions[0]['legs']:
                            leg = directions[0]['legs'][0]
                            
                            refuge = {
                                "nom": place['name'],
                                "type": self.categorize_place_type(query, place),
                                "adresse": place.get('vicinity', 'Adresse non disponible'),
                                "distance": leg['distance']['text'],
                                "temps_marche": leg['duration']['text'],
                                "rating": place.get('rating', 0),
                                "ouvert_maintenant": place.get('opening_hours', {}).get('open_now', False),
                                "place_id": place['place_id'],
                                "urgence": "police" in query.lower() or "hospital" in query.lower()
                            }
                            
                            refuges.append(refuge)
                            
                except Exception as e:
                    self.logger.warning(f"Erreur recherche {query}: {e}")
                    continue
            
            # Trier par priorit√© (urgence d'abord, puis distance)
            refuges.sort(key=lambda x: (not x.get('urgence', False), 
                                      self.extract_distance_meters(x['distance'])))
            
            self.logger.info(f"‚úÖ {len(refuges)} refuges trouv√©s dynamiquement")
            return refuges[:6]  # Limiter √† 6 refuges
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur recherche dynamique : {e}")
            return self.get_fallback_refuges()
    
    def extract_distance_meters(self, distance_text: str) -> float:
        """Extrait la distance en m√®tres depuis le texte Google"""
        try:
            if 'km' in distance_text:
                return float(distance_text.replace('km', '').replace(' ', '').replace(',', '.')) * 1000
            elif 'm' in distance_text:
                return float(distance_text.replace('m', '').replace(' ', '').replace(',', '.'))
            else:
                return 9999  # Valeur par d√©faut si parsing √©choue
        except:
            return 9999
    
    def categorize_place_type(self, query: str, place: Dict) -> str:
        """Cat√©gorise le type de lieu en fonction de la requ√™te et des donn√©es"""
        place_types = place.get('types', [])
        
        if 'police' in query.lower() or 'police' in place_types:
            return "police"
        elif 'hospital' in query.lower() or any(t in place_types for t in ['hospital', 'health']):
            return "medical"  
        elif 'hotel' in query.lower() or 'lodging' in place_types:
            return "hebergement"
        elif 'pharmacy' in query.lower() or 'pharmacy' in place_types:
            return "pharmacie"
        elif 'metro' in query.lower() or 'transit_station' in place_types:
            return "transport"
        else:
            return "commerce"
    
    def get_fallback_refuges(self) -> List[Dict]:
        """Refuges de fallback si Google Maps n'est pas disponible"""
        return [
            {
                "nom": "Commissariat du 9√®me arrondissement",
                "type": "police",
                "adresse": "14-16 Rue Chauchat, 75009 Paris",
                "distance": "400m",
                "temps_marche": "5 minutes",
                "ouvert_maintenant": True,
                "urgence": True
            },
            {
                "nom": "Gare Saint-Lazare - S√©curit√© SNCF",
                "type": "transport", 
                "adresse": "Place du Havre, 75008 Paris",
                "distance": "600m",
                "temps_marche": "7 minutes",
                "ouvert_maintenant": True,
                "urgence": False
            }
        ]
    
    def analyze_situation_with_vertex_ai(self, user_message: str) -> str:
        """Analyse la situation avec Vertex AI en temps r√©el"""
        if not self.ai_available or not self.vertex_ai:
            return self.analyze_situation_basic(user_message)
        
        try:
            print("üß† Analyse Vertex AI en temps r√©el...")
            
            # Contexte enrichi pour l'IA
            current_time = datetime.now()
            context_prompt = f"""
            CONTEXTE SITUATION D'URGENCE:
            - Localisation: {self.location_google_paris['address']}
            - Coordonn√©es: {self.location_google_paris['latitude']}, {self.location_google_paris['longitude']}
            - Heure actuelle: {current_time.strftime('%H:%M')} le {current_time.strftime('%d/%m/%Y')}
            - Quartier: {self.location_google_paris['quartier']}
            - M√©tro proche: {self.location_google_paris['metro_proche']}
            - Message utilisateur: "{user_message}"
            
            Analysez cette situation d'urgence et fournissez:
            1. Niveau de risque (Faible/Moyen/√âlev√©/Critique)
            2. Actions imm√©diates recommand√©es
            3. Contexte local sp√©cifique √† Paris 9√®me
            4. Recommandations de s√©curit√© personnelle
            """
            
            # Appel √† Vertex AI
            analysis = self.vertex_ai.analyze_emergency_situation(
                context_prompt,
                additional_context={
                    "location": self.location_google_paris,
                    "timestamp": current_time.isoformat(),
                    "user_input": user_message
                }
            )
            
            print("‚úÖ Analyse IA termin√©e")
            return f"""
üß† ANALYSE VERTEX AI (Intelligence Artificielle LIVE):

{analysis}

üìç CONTEXTE G√âOGRAPHIQUE ANALYS√â:
   - Zone: Paris 9√®me arrondissement (quartier d'affaires)
   - Proximit√©: Bureaux Google France, Gare Saint-Lazare
   - S√©curit√©: Zone g√©n√©ralement s√ªre mais vigilance nocturne requise
"""
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur analyse Vertex AI : {e}")
            print(f"‚ö†Ô∏è  Fallback vers analyse basique (erreur IA : {e})")
            return self.analyze_situation_basic(user_message)
    
    def analyze_situation_basic(self, user_message: str) -> str:
        """Analyse basique si l'IA n'est pas disponible"""
        current_time = datetime.now()
        return f"""
üîç ANALYSE DE LA SITUATION (mode basique):

üìç Localisation : {self.location_google_paris['address']}
üïö Heure : {current_time.strftime('%H:%M')} - Heure actuelle
‚ö†Ô∏è  Alerte utilisateur : {user_message}

üéØ NIVEAU DE RISQUE : MOYEN-√âLEV√â
   - Situation d'alerte exprim√©e par l'utilisateur
   - Quartier anim√© mais zones isol√©es possibles
   - Intervention recommand√©e

üí° RECOMMANDATIONS IMM√âDIATES :
   - Se diriger vers un lieu public √©clair√©
   - √âviter les rues sombres/isol√©es
   - Pr√©parer le t√©l√©phone pour appeler les secours
   - Utiliser les refuges recommand√©s
"""
    
    def get_refuge_recommendations(self, user_message: str) -> str:
        """G√©n√®re les recommandations de refuges via recherche dynamique"""
        
        # Recherche dynamique des refuges
        refuges = self.find_refuges_dynamically(user_message)
        
        if not refuges:
            return "\n‚ùå Aucun refuge trouv√©. Contactez le 17 (Police) ou 112 (Urgence)"
        
        recommendations = "\nüèõÔ∏è  REFUGES TROUV√âS DYNAMIQUEMENT (Google Maps + IA):\n"
        
        for i, refuge in enumerate(refuges, 1):
            # Ic√¥nes selon le type et l'urgence
            if refuge.get("urgence", False):
                icon = "üö®"
            elif refuge["type"] == "police":
                icon = "üëÆ"
            elif refuge["type"] == "medical":
                icon = "üè•"
            elif refuge["type"] == "transport":
                icon = "üöá"
            elif refuge["type"] == "pharmacie":
                icon = "üíä"
            else:
                icon = "üè¢"
            
            # Statut ouverture
            if refuge.get("ouvert_maintenant", False):
                status = "üü¢ OUVERT MAINTENANT"
            else:
                status = "üî¥ V√©rifier horaires"
            
            recommendations += f"\n{icon} {i}. {refuge['nom']}"
            recommendations += f"\n   üìç {refuge['adresse']}"
            recommendations += f"\n   üö∂ Distance : {refuge['distance']} ({refuge['temps_marche']})"
            recommendations += f"\n   {status}"
            
            if refuge.get("rating", 0) > 0:
                recommendations += f"\n   ‚≠ê Note Google : {refuge['rating']}/5"
            
            recommendations += "\n"
        
        recommendations += "\nüí° Refuges trouv√©s en temps r√©el via Google Maps API"
        return recommendations
    
    def generate_voice_response_live(self, user_message: str) -> bool:
        """G√©n√®re une r√©ponse vocale LIVE avec Google Text-to-Speech"""
        try:
            print("\nüîä R√âPONSE VOCALE LIVE (Google Text-to-Speech):")
            
            if not self.vocal_available or not self.speech_agent:
                print("‚ö†Ô∏è  Agent vocal non disponible")
                return False
            
            # G√©n√©rer un message vocal personnalis√© bas√© sur l'analyse IA
            current_time = datetime.now()
            
            # Message vocal adaptatif bas√© sur le message utilisateur
            if "suivi" in user_message.lower() or "poursuivi" in user_message.lower():
                situation = "√™tre suivi"
                action = "dirigez-vous imm√©diatement vers le lieu public le plus proche"
            elif "peur" in user_message.lower() or "inquiet" in user_message.lower():
                situation = "inqui√©tude"
                action = "restez calme et suivez mes recommandations"
            elif "danger" in user_message.lower() or "aide" in user_message.lower():
                situation = "danger potentiel" 
                action = "prenez les mesures de s√©curit√© imm√©diatement"
            else:
                situation = "situation d'alerte"
                action = "suivez les recommandations de s√©curit√©"
            
            vocal_response = f"""
            Je comprends votre {situation}. Vous √™tes actuellement pr√®s des bureaux Google Paris, dans le 9√®me arrondissement. 
            Il est {current_time.strftime('%H heures %M')}.
            
            J'ai analys√© votre situation et trouv√© des refuges pr√®s de vous. {action}.
            
            En cas d'urgence imm√©diate, composez le 17 pour la police ou le 112 pour les secours.
            
            Je peux contacter vos proches si vous le souhaitez. Restez en s√©curit√©.
            """
            
            print(f"üéôÔ∏è  Message personnalis√© : {vocal_response.strip()}")
            
            # VRAIE synth√®se vocale Google TTS
            try:
                print("üîä Synth√®se vocale Google TTS en cours...")
                self.speech_agent.speak(vocal_response.strip())
                print("‚úÖ Synth√®se vocale termin√©e")
                return True
            except Exception as tts_error:
                print(f"‚ö†Ô∏è  Erreur TTS : {tts_error}")
                print("üîä [Mode texte - synth√®se vocale non disponible]")
                return False
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur r√©ponse vocale : {e}")
            print("‚ö†Ô∏è  Erreur lors de la g√©n√©ration vocale")
            return False
    
    def generate_emergency_email_live(self, user_message: str) -> bool:
        """G√©n√®re et envoie un VRAI email d'urgence avec les APIs configur√©es"""
        try:
            print("\nüìß G√âN√âRATION EMAIL D'URGENCE LIVE...")
            
            # R√©cup√©rer les VRAIS contacts d'urgence depuis la configuration
            emergency_contacts = self.api_config.get('emergency_contacts', [])
            
            if not emergency_contacts:
                print("‚ö†Ô∏è  Aucun contact d'urgence configur√© dans api_keys.yaml")
                print("   Ajoutez vos contacts dans la section 'emergency_contacts'")
                return False
            
            if not self.email_generator:
                print("‚ùå G√©n√©rateur d'email non disponible")
                return False
                
            # Localisation r√©elle pour l'email
            location_tuple = (
                self.location_google_paris['latitude'], 
                self.location_google_paris['longitude']
            )
            
            current_time = datetime.now()
            
            print("üìç G√©n√©ration email avec donn√©es LIVE...")
            print(f"   üìç Position r√©elle : {self.location_google_paris['address']}")
            print(f"   üïö Heure actuelle : {current_time.strftime('%H:%M')}")
            print("   üó∫Ô∏è  Carte Google Maps (API LIVE)")
            print("   üéØ What3Words (API LIVE)")
            
            try:
                # VRAIE g√©n√©ration d'email avec APIs
                print("\nüîÑ G√©n√©ration du contenu email via APIs...")
                
                email_content = self.email_generator.generate_emergency_email(
                    location_tuple, 
                    f"ALERTE URGENTE: {user_message}",
                    "urgent"
                )
                
                if email_content:
                    print("‚úÖ Email g√©n√©r√© avec succ√®s (contenu HTML + cartes)")
                    
                    # Afficher les contacts qui vont recevoir l'email
                    print(f"\nüì§ ENVOI √Ä {len(emergency_contacts)} CONTACTS CONFIGUR√âS :")
                    
                    for i, contact in enumerate(emergency_contacts, 1):
                        relation_icon = {
                            "famille": "üë®‚Äçüë©‚Äçüëß‚Äçüë¶",
                            "ami": "ü§ù", 
                            "m√©decin": "üë©‚Äç‚öïÔ∏è"
                        }.get(contact.get("relation", ""), "üë§")
                        
                        print(f"\n   {relation_icon} {i}. {contact.get('name', 'Contact')}")
                        print(f"      üìß Email : {contact.get('email', 'N/A')}")
                        if contact.get('phone'):
                            print(f"      üì± T√©l√©phone : {contact['phone']}")
                        print(f"      ‚úÖ Email pr√©par√© pour envoi")
                        
                        # D√©lai r√©aliste entre les envois
                        time.sleep(0.5)
                    
                    print(f"\nüéØ CONTENU EMAIL G√âN√âR√â (LIVE) :")
                    print("‚îÅ" * 60)
                    print("üö® ALERTE GUARDIANNAV - URGENCE D√âTECT√âE")
                    print("‚îÅ" * 60)
                    print(f"üìÖ Timestamp : {current_time.strftime('%d/%m/%Y √† %H:%M:%S')}")
                    print(f"üìç Localisation : {self.location_google_paris['address']}")
                    print(f"‚ö†Ô∏è  Message utilisateur : {user_message}")
                    print(f"ü§ñ Analyse : Situation d'urgence d√©tect√©e par IA")
                    print("")
                    print("üÜò INFORMATIONS POUR INTERVENTION :")
                    print(f"   ‚Ä¢ Coordonn√©es GPS pr√©cises : {self.location_google_paris['latitude']}, {self.location_google_paris['longitude']}")
                    print("   ‚Ä¢ Carte interactive Google Maps incluse")
                    print("   ‚Ä¢ Adresse What3Words pour localisation ultra-pr√©cise")
                    print("   ‚Ä¢ Refuges les plus proches calcul√©s en temps r√©el")
                    print("")
                    print("üì± Email automatique GuardianNav - Intervention imm√©diate recommand√©e")
                    print("‚îÅ" * 60)
                    
                    print("\n‚úÖ Email d'urgence g√©n√©r√© et pr√™t √† l'envoi")
                    print("   (Envoi automatique selon configuration)")
                    return True
                    
                else:
                    raise Exception("√âchec g√©n√©ration contenu email")
                    
            except Exception as email_error:
                self.logger.error(f"Erreur g√©n√©ration email live : {email_error}")
                print(f"‚ùå Erreur g√©n√©ration : {email_error}")
                return False
                
        except Exception as e:
            self.logger.error(f"‚ùå Erreur email d'urgence : {e}")
            print(f"‚ö†Ô∏è  Erreur lors de l'email d'urgence : {e}")
            return False
    
    def generate_emergency_response_live(self, user_message: str):
        """G√©n√®re une r√©ponse d'urgence compl√®te avec toutes les APIs LIVE"""
        print("\nü§ñ GUARDIANNAV ANALYSE LA SITUATION EN TEMPS R√âEL...")
        
        # 1. Analyse de la situation avec Vertex AI
        analysis = self.analyze_situation_with_vertex_ai(user_message)
        print(analysis)
        
        # 2. Recommandations de refuges (recherche dynamique Google Maps)
        refuges = self.get_refuge_recommendations(user_message)
        print(refuges)
        
        # 3. Actions imm√©diates
        actions = self.get_immediate_actions()
        print(actions)
        
        # 4. R√©ponse vocale LIVE si disponible
        vocal_success = False
        if self.vocal_available:
            vocal_success = self.generate_voice_response_live(user_message)
        
        # 5. Proposition de contacter les proches
        self.propose_contact_proches(vocal_success)
        
        # 6. G√©n√©ration email d'urgence LIVE si confirm√©
        if self.email_available:
            self.generate_emergency_email_live(user_message)
    
    def get_immediate_actions(self) -> str:
        """Actions imm√©diates recommand√©es"""
        current_time = datetime.now()
        return f"""
‚ö° ACTIONS IMM√âDIATES RECOMMAND√âES ({current_time.strftime('%H:%M')}):

üö® URGENCE IMM√âDIATE :
   ‚Ä¢ Composer le 17 (Police) ou 112 (Urgence europ√©enne)
   ‚Ä¢ SMS au 114 pour les personnes sourdes/malentendantes

üõ°Ô∏è  S√âCURIT√â PERSONNELLE :
   ‚Ä¢ Utiliser les refuges trouv√©s dynamiquement ci-dessus
   ‚Ä¢ Rester dans les zones √©clair√©es et fr√©quent√©es
   ‚Ä¢ √âviter les ruelles sombres du 9√®me arrondissement

üì± COMMUNICATION :
   ‚Ä¢ Garder le t√©l√©phone en main, batterie charg√©e
   ‚Ä¢ Partager sa position avec un proche de confiance
   ‚Ä¢ GuardianNav peut contacter vos proches automatiquement

üö∂ D√âPLACEMENT S√âCURIS√â :
   ‚Ä¢ Privil√©gier : Boulevard Haussmann (tr√®s fr√©quent√©)
   ‚Ä¢ Metro : Ligne 3 station Europe (proche et s√ªre)
   ‚Ä¢ √âviter les zones isol√©es identifi√©es par l'IA
"""
    
    def propose_contact_proches(self, vocal_available: bool = False):
        """Propose de contacter les proches et simule la r√©ponse utilisateur"""
        print("\nüë• CONTACT DES PROCHES")
        print("‚îÅ" * 40)
        
        print("ü§ñ GuardianNav : \"Souhaitez-vous que je contacte vos proches pour les informer de votre situation ?\"")
        
        # En mode d√©mo, on simule automatiquement la r√©ponse "oui"
        print("üë§ Vous : \"Oui, s'il te pla√Æt, pr√©viens-les imm√©diatement !\"")
        
        if vocal_available:
            print("üîä GuardianNav (vocal) : \"D'accord, j'envoie imm√©diatement un email d'alerte √† vos contacts d'urgence avec votre localisation pr√©cise.\"")
        
        print("ü§ñ Action : D√©clenchement automatique de l'alerte aux contacts d'urgence...")
        
        # Simulation d'un petit d√©lai de traitement
        time.sleep(1)
    
    def print_context_demo(self):
        """Affiche le contexte de la d√©monstration"""
        current_time = datetime.now()
        print("\n" + "="*80)
        print("üé≠ D√âMONSTRATION GUARDIANNAV LIVE - INTELLIGENCE ARTIFICIELLE")
        print("="*80)
        print(f"üìç Localisation : {self.location_google_paris['address']}")
        print(f"üè¢ Pr√®s de : Google France (8 Rue de Londres)")
        print(f"üïö Heure ACTUELLE : {current_time.strftime('%H:%M')} le {current_time.strftime('%d/%m/%Y')}")
        print(f"‚ö†Ô∏è  Situation : Test d'alerte avec vraies APIs")
        print(f"üéØ Objectif : D√©monstration intelligence artificielle en temps r√©el")
        print("="*80)
        
        # Status des agents LIVE
        print("\nüîß STATUS DES AGENTS (MODE LIVE) :")
        print(f"   Guardian Agent : {'‚úÖ Activ√©' if self.guardian else '‚ùå Erreur'}")
        print(f"   Vertex AI : {'‚úÖ LIVE' if self.ai_available else '‚ùå Non disponible'}")
        print(f"   Google Maps : {'‚úÖ LIVE' if self.google_maps_client else '‚ùå Non disponible'}")
        print(f"   Agent Vocal : {'‚úÖ LIVE (Google TTS)' if self.vocal_available else '‚ùå Non disponible'}")
        print(f"   Email Urgence : {'‚úÖ LIVE' if self.email_available else '‚ùå Non disponible'}")
    
    def run_demo_live_conversation(self):
        """Lance une conversation de d√©monstration LIVE interactive"""
        print("\nüí¨ CONVERSATION INTERACTIVE LIVE - TEST INTELLIGENCE IA")
        print("-" * 60)
        
        # Messages de d√©monstration adapt√©s au mode live
        demo_messages = [
            "Bonjour GuardianNav, je pense √™tre suivi depuis 5 minutes",
            "Je suis pr√®s des bureaux Google √† Paris et j'ai peur",
            "Qu'est-ce que je peux faire ? O√π puis-je aller en s√©curit√© ?",
            "Y a-t-il un commissariat ou un refuge proche de moi ?",
            "Peux-tu analyser ma situation avec l'IA et pr√©venir mes contacts ?",
            "Je me sens en danger, utilise toutes tes capacit√©s pour m'aider",
            "Teste ton intelligence artificielle pour cette urgence"
        ]
        
        print("\nüé≠ MESSAGES DE TEST INTELLIGENCE LIVE :")
        for i, msg in enumerate(demo_messages, 1):
            print(f"   {i}. \"{msg}\"")
        
        print(f"\nüìù Tapez le num√©ro du message (1-{len(demo_messages)}) ou votre propre message :")
        print("   (Tapez 'quit' pour terminer la d√©mo)")
        
        while True:
            try:
                user_input = input("\nüë§ Votre message : ").strip()
                
                if user_input.lower() in ['quit', 'exit', 'q']:
                    print("üëã Fin de la d√©monstration GuardianNav LIVE")
                    break
                
                # V√©rifier si c'est un num√©ro de message pr√©d√©fini
                if user_input.isdigit():
                    msg_index = int(user_input) - 1
                    if 0 <= msg_index < len(demo_messages):
                        message = demo_messages[msg_index]
                    else:
                        print(f"‚ùå Num√©ro invalide. Choisissez entre 1 et {len(demo_messages)}.")
                        continue
                else:
                    message = user_input
                
                if not message.strip():
                    print("‚ùå Message vide. Veuillez entrer un message.")
                    continue
                
                # Simuler l'entr√©e vocale
                print(f"\nüë§ UTILISATEUR (message re√ßu) : \"{message}\"")
                if self.vocal_available:
                    print("üîä [Reconnaissance vocale activ√©e - message trait√©]")
                
                # G√©n√©rer la r√©ponse d'urgence LIVE
                self.generate_emergency_response_live(message)
                
                print("\n" + "-" * 60)
                
            except KeyboardInterrupt:
                print("\n\nüëã D√©monstration interrompue par l'utilisateur")
                break
            except Exception as e:
                print(f"‚ùå Erreur : {e}")
                continue
    
    def run_demo(self):
        """Lance la d√©monstration compl√®te LIVE"""
        try:
            # Afficher le contexte
            self.print_context_demo()
            
            # Test automatique avec un message type
            print("\nüöÄ D√âMONSTRATION AUTOMATIQUE LIVE")
            print("-" * 40)
            
            demo_message = "Je pense √™tre suivi depuis 5 minutes pr√®s de Google Paris, j'ai peur et j'ai besoin d'aide"
            print(f"\nüë§ UTILISATEUR (test automatique) : \"{demo_message}\"")
            if self.vocal_available:
                print("üîä [Message re√ßu via reconnaissance vocale]")
            
            self.generate_emergency_response_live(demo_message)
            
            # Proposer la d√©mo interactive
            print("\n" + "="*80)
            print("üéØ Voulez-vous tester la conversation interactive LIVE ? (o/n)")
            
            try:
                response = input().lower().strip()
                if response.startswith('o'):
                    self.run_demo_live_conversation()
                else:
                    print("üëã D√©monstration LIVE termin√©e")
            except:
                print("üëã D√©monstration LIVE termin√©e")
                
        except Exception as e:
            self.logger.error(f"Erreur lors de la d√©monstration : {e}")
            print(f"‚ùå Erreur : {e}")

def main():
    """Point d'entr√©e principal"""
    print("üöÄ Lancement de la d√©monstration GuardianNav LIVE - Intelligence Artificielle")
    
    try:
        demo = DemoLiveAlerteParis()
        demo.run_demo()
        
    except KeyboardInterrupt:
        print("\n\nüëã D√©monstration interrompue")
    except Exception as e:
        print(f"‚ùå Erreur fatale : {e}")
        print("\nV√©rifiez que :")
        print("   - Le fichier api_keys.yaml est configur√©")
        print("   - Les APIs Google Cloud sont activ√©es")
        print("   - Vertex AI est correctement configur√©")
        return 1
    
    return 0

if __name__ == "__main__":
    exit(main())